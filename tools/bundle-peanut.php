<?php
/**
 * Created by PhpStorm.
 * User: Terry
 * Date: 5/22/2017
 * Time: 5:39 AM

 * Deployment notes:
 * Change distribution->bundle setting in settings.ini to 1
 * Deploy all files in pnut/core EXCEPT those listed $exclusions array
 */

// NOTE: iniFilePath is the only hard coded path.  Change the constant as needed.
const iniFilePath = 'application/config/settings.ini';
const stripComments = true;
const stripBlankLines = true;
const trimLeft = false;
const rebuildTsConfig = false;

$modules = array(
    'KnockoutHelper',
    'WaitMessage',
    'App',
    'Services',
    'ViewModelBase'
);

$exclusions = array('Peanut.d.ts','PeanutLoader.ts');


function checkReference($sources, &$references, $exclusions, $line) {
    if (stristr($line,'<reference path') === false) {
        return false;
    }
    foreach ($exclusions as $exclusion) {
        if (stristr($line,$exclusion) !== false) {
            return true;
        }
    }
    foreach ($sources as $source) {
        if (stristr($line,$source)!== false) {
            return true;
        }
    }
    $line = rtrim( str_replace('"',"'",$line));
    $line = rtrim( str_replace('///<',"/// <",$line));
    $line = rtrim( str_replace("'/>","' />",$line));
    if (!in_array($line, $references)) {
        $references[] = $line;
    }
    return true;
}

$buildHeader =  sprintf("/**\n * Generated by tools/bundle-peanut.php\n * %s\n */\n\n", (new DateTime())->format('Y-m-d H:i:s'));
$basePath = realpath(__DIR__.'/../pnut.root');
if ($basePath === false) {
    throw new Exception("Base path not found: $basePath");
}

$configPath = $basePath.'/'.iniFilePath;
$ini = parse_ini_file($configPath,true);
if ($ini === false) {
    throw new Exception("Config Path not found: $configPath");
}
$settings = $ini['peanut'];

$corePath = realpath($basePath.'/modules/pnut/core');
if ($corePath === false) {
    throw new Exception("Core path not found: $corePath");
}
$outPath = realpath($basePath.'/modules/pnut/dist');
if ($outPath === false) {
    throw new Exception("Out path not found: $outPath");
}

if (rebuildTsConfig) {
    $tsConfig = file($outPath . '\tsconfig.json');
    if ($tsConfig == false) {
        throw new Exception('No tsconfig.json in dist folder.');
    }
}

$tsExclude = array();

$constants = array();
$sources = array();
$coreRefPath = "/// <reference path='../core/%s' />";
$definitionsRef = sprintf($coreRefPath,'Peanut.d.ts');
$loaderRef = sprintf($coreRefPath,'PeanutLoader.ts');
$references = array($definitionsRef,$loaderRef);;
foreach ($modules as $module) {
    $source = strtolower("$module.ts");
    $sources[] = $source;
    $tsExclude[] = sprintf('"../core/%s"',$source);
}

$end = sizeof($tsExclude) -1;
for ($i = 0; $i<=$end;$i++) {
    if ($i<$end) {
        $tsExclude[$i] .= ',';
    }
    $tsExclude[$i] .= "\r\n";
}

$combined = array();
foreach ($modules as $module) {
    $filePath = $corePath."/$module.ts";
    // print "$module: $filePath\n";
    $lines = file($filePath);
    if ($lines === false) {
        throw new Exception("Source file not found: $filePath");
    }
    $cmt = $module == 'App' ? 'Application' : $module;
    $combined[] = '// module: '.  $cmt;
    $inComment = false;
    foreach ($lines as $line) {
        if ($inComment) {
            $comment = strstr($line,'*/');
            if ($comment !== false) {
                $line = rtrim(substr($comment,2));
                $inComment = false;
            }
            else {
                continue;
            }
        }
        else if (stripComments) {
            $comment = strstr($line,'/*',true);
            if ($comment !== false) {
                $line = rtrim($comment);
                $inComment = true;
            }
        }
        $nospace = trim(str_replace(' ','',$line));
        if ((substr($nospace,0,9) === "namespace" && substr($nospace,-1) == '{') || $nospace == '}//endnamespace') {
            continue;
        }

        if (stristr($line,'const ')) {
            $constants[] = trimLeft ? trim($line) : rtrim($line);
            continue;
        }
        /*
        if (empty($line)) {
            continue;
        }
        */
        if (checkReference($sources,$references,$exclusions,$line)) {
            continue;
        }
        if (stripComments) {
            $comment = strstr($line, '//', true);
            if ($comment !== false) {
                $line = $comment;
            }
        }

        $line = rtrim($line);
        if (stripBlankLines && empty($line)) {
            continue;
        }

        if (trimLeft) {
            $line = ltrim($line);
        }
        $combined[] = $line;
    }
}
if (rebuildTsConfig) {
    $tsExcludesStart = false;
    $tsExcludesEnd = false;

    $tsConfigEnd = array();
    $tslen = sizeof($tsConfig);
    for ($i = 0; $i < $tslen; $i++) {
        if ($tsExcludesStart !== false) {
            if (stristr($tsConfig[$i], ']') !== false) {
                $tsExcludesEnd = $i;
                break;
            }
        }
        if (stristr($tsConfig[$i], '"exclude"') !== false) {
            $tsExcludesStart = $i + 1;
        }
    }

    $tsConfig = array_merge(
        array_slice($tsConfig, 0, $tsExcludesStart),
        $tsExclude,
        array_slice($tsConfig, $tsExcludesEnd));

    print "\nUpdating " . $outPath . "/tsconfig.json";

    file_put_contents($outPath . "/tsconfig.json", implode($tsConfig));
}

$references[] = "namespace Peanut {";
$srcText = $buildHeader.(implode("\n",array_merge($references,$constants,$combined))."\n} // end namespace\n");
print "\nWriting to ".$outPath."/Peanut.ts";
file_put_contents($outPath."/Peanut.ts",$srcText);

print "\nPeanut.ts merge completed.\n";